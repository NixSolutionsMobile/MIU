//
//  MIUFileAnalyzer.m
//  MIU
//
//  Created by Vlad Yalovenko on 01/12/2016.
//  Copyright Â© 2016 NIX. All rights reserved.
//
#import "MIUFileAnalyzer.h"
#import "MIUFileGenerator.h"
#import "MIUObjectsScanner.h"
#import "MIUClass.h"
#import "MIUMethod.h"
#import "MIUImplementation.h"
#import "MIUCopyWithZone.h"
#import "MIUEncodeWithCoder.h"
#import "MIUIsEqual.h"
#import "MIUInitWithCoder.h"
#import "MIUProtocolConfigurator.h"
#import "MIUDescription.h"
#import "MIUHash.h"
#import "MIUEnumsScanner.h"
#import "MIUClassStatistics.h"

#import "MIUProjectsManager.h"

@interface MIUFileAnalyzer()

@property(nonatomic, strong) NSString *resultFileContent;
@property(nonatomic, assign) BOOL isCurrentMethodIsAutoGenerated;
@property(nonatomic, assign) int lastOneMethodBracketIndex;
@property(nonatomic, assign) NSRange headerRangeOfCurrentMethod;

@end

@implementation MIUFileAnalyzer

- (NSArray<MIUClassStatistics *> *)analyzeFilesFromFilesAtPaths:(NSSet *)paths withRootProjectPath:(NSSet *)rootProjectPath inProject:(MIUProjectModel *)project
{
    MIUObjectsScanner *factory = [MIUObjectsScanner new];
    NSSet *classes = [factory classesFromPaths:paths withRootProjectPath:paths];
    NSMutableArray *classStatistics = [NSMutableArray new];
    NSSet *enums = [factory enumsFromPaths:rootProjectPath];
    
    for (MIUClass *class in classes)
    {
        if ([[class properties] count] != 0 || ![class isBase])
        {
            NSString *contentOfFile = [NSString stringWithContentsOfFile:[[class implementation] filePath] encoding:NSUTF8StringEncoding error:nil];
            BOOL result = NO;
            
            if (contentOfFile != nil)
            {
                if ([self checkClassForUpdate:class WithOldProperties:[[MIUProjectsManager sharedManager] getClassesForProject:project]])
                {
                    result = YES;
                }
                MIUClassStatistics *statistics = [self editFile:contentOfFile withClass:class enums:enums];
                [statistics setIsClassNeedUpdate:result];
                [classStatistics addObject:statistics];
            }
        }
    }
    return classStatistics;
}

- (BOOL)checkClassForUpdate:(MIUClass *)class WithOldProperties:(NSArray<MIUClass *> *)oldProperties
{
    BOOL result = NO;
    for (int i = 0; i < [oldProperties count]; i++)
    {
        if ([[class name] isEqualTo:[[oldProperties objectAtIndex:i] name]])
        {
            if (![[class properties]isEqualToSet:[[oldProperties objectAtIndex:i] properties]])
            {
                result = YES;
            }
        }
    }
    return result;
}

- (MIUClassStatistics *)editFile:(NSString *)file withClass:(MIUClass *)class enums:(NSSet *)enums
{
    NSMutableArray *methodStatistics = [NSMutableArray new];
    
    MIUClassStatistics *statistic = [MIUClassStatistics new];
    [statistic setGeneratingClass:class];
    
    MIUCopyWithZone *copyWithZoneMethod = [[MIUCopyWithZone alloc] initWithName:@"copyWithZone" returnType:@"id" isPointerReturnType:NO argName:@"theZone" argType:@"NSZone" isPointerArgType:YES];
    MIUMethodStatistics *copyWithZoneStatistics = [self fileChecker:file toExistedMethod:copyWithZoneMethod withClass:class];
    [copyWithZoneStatistics setProblematicProperties:[copyWithZoneMethod problematicProperties]];
    
    MIUEncodeWithCoder *encodeWithCoderMethod = [[MIUEncodeWithCoder alloc] initWithName:@"encodeWithCoder" returnType:@"void" isPointerReturnType:NO argName:@"theCoder" argType:@"NSCoder"isPointerArgType:YES];
    MIUMethodStatistics *encodeWithCoderStatistics = [self fileChecker:_resultFileContent toExistedMethod:encodeWithCoderMethod withClass:class];
    [encodeWithCoderStatistics setProblematicProperties:[encodeWithCoderMethod problematicProperties]];
    
    MIUInitWithCoder *initWithCoder = [[MIUInitWithCoder alloc] initWithName:@"initWithCoder" returnType:@"id" isPointerReturnType:NO argName:@"theDecoder" argType:@"NSCoder" isPointerArgType:YES];
    MIUMethodStatistics *initWithCoderStatistics = [self fileChecker:_resultFileContent toExistedMethod:initWithCoder withClass:class];
    [initWithCoderStatistics setProblematicProperties:[initWithCoder problematicProperties]];
    
    MIUIsEqual *isEqualMethod = [[MIUIsEqual alloc] initWithName:@"isEqual" returnType:@"BOOL" isPointerReturnType:NO argName:@"theObject" argType:[NSString stringWithFormat:@"%@", [class name]] isPointerArgType:YES];
    [isEqualMethod setEnums:enums];
    MIUMethodStatistics *isEqualStatistics = [self fileChecker:_resultFileContent toExistedMethod:isEqualMethod withClass:class];
    [isEqualStatistics setProblematicProperties:[isEqualMethod problematicProperties]];
    
    MIUDescription *decriptionMethod = [[MIUDescription alloc] initWithName:@"description" returnType:@"NSString" isPointerReturnType:YES argName:nil argType:nil isPointerArgType:NO];
    [decriptionMethod setEnums:enums];
    MIUMethodStatistics *decriptionStatistics = [self fileChecker:_resultFileContent toExistedMethod:decriptionMethod withClass:class];
    [decriptionStatistics setProblematicProperties:[decriptionMethod problematicProperties]];
    
    MIUHash *hashMethod = [[MIUHash alloc] initWithName:@"hash" returnType:@"NSUInteger" isPointerReturnType:NO argName:nil argType:nil isPointerArgType:NO];
    [hashMethod setEnums:enums];
    MIUMethodStatistics *hashStatistics = [self fileChecker:_resultFileContent toExistedMethod:hashMethod withClass:class];
    [hashStatistics setProblematicProperties:[hashMethod problematicProperties]];
    
    [methodStatistics addObjectsFromArray:@[copyWithZoneStatistics, encodeWithCoderStatistics, initWithCoderStatistics, isEqualStatistics, decriptionStatistics, hashStatistics]];
    [statistic setMethodsStatistic:methodStatistics];
    
    return statistic;
}

- (MIUMethodStatistics *)fileChecker:(NSString *)file toExistedMethod:(MIUMethod *)method withClass:(MIUClass *)class
{
    MIUMethodStatistics *methodStatistics = [MIUMethodStatistics new];
    MIUMethodState state;
    
    _isCurrentMethodIsAutoGenerated = NO;
    _resultFileContent = [file copy];
    
    if ([self checkExistingMethodWithSignature:method inString:file])
    {
        state = MIUMethodStateSupportedByUser;
        
        if ([self isCurrentMethodIsAutoGenerated] == YES)
        {
            state = MIUMethodStateTheSame;

        }
    }
    
    [methodStatistics setState:state];
    [methodStatistics setMethod:method];
    
    return methodStatistics;
}

- (BOOL)checkExistingMethodWithSignature:(MIUMethod *)method inString:(NSString *)fileContent
{
    NSString *pattern;
    
    if ([method isKindOfClass:[MIUIsEqual class]] ||
        [method isKindOfClass:[MIUHash class]] ||
        [method isKindOfClass:[MIUDescription class]])
    {
        // pattern to check existence already generated method IsEqual, hash, description
        pattern = [NSString stringWithFormat:@"(\\s*\\/\\/ \\bgenerated\\b\\s*){0,1}\\-\\s*\\(\\s*%@\\s*%@\\)\\s*%@\\s*((\\:\\s*\\(\\s*%@\\s*%@\\)\\s*\\w*)){0,1}\\s*"
                   , [NSString stringWithFormat:@"(?:\\b%@\\b|\\bid\\b)", [method returnType]], [method isPointerReturnType] ? @"\\*\\s*" : @"", [method name], [NSString stringWithFormat:@"(?:%@|id)", [method argumentType]], [method isPointerArgumentType] ? @"\\*\\s*" : @""];
    }
    else
    {
        // pattern to check existence already generated method initWithCoder, encodeWithCoder
        pattern = [NSString stringWithFormat:@"(\\s*\\/\\/ \\bgenerated\\b\\s*){0,1}\\-\\s*\\((\\s*%@\\s*%@\\s*\\)\\s*%@\\s*\\:\\s*\\(\\s*%@\\s*%@\\s*\\)\\s*\\w*)\\s*", [method returnType], [method isPointerReturnType] ? @"\\*" : @"", [method name], [method argumentType], [method isPointerArgumentType] ? @"\\*" : @""];
    }
    
    NSRegularExpression *regex = [NSRegularExpression regularExpressionWithPattern:pattern options:0 error:NULL];
    
    NSTextCheckingResult *match = [regex firstMatchInString:fileContent options:0 range:NSMakeRange(0, [fileContent length])];
    
    if (match != nil)
    {
        _headerRangeOfCurrentMethod = [match rangeAtIndex:0];
        
        if ([match rangeAtIndex:1].length != 0)
        {
            _isCurrentMethodIsAutoGenerated = YES;
        }
        
        return YES;
    }
    
    return NO;
}


@end
