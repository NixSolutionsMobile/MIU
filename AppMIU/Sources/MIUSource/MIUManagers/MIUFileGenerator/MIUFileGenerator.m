//
//  MIUFileGenerator.m
//  ModelImprovmentUtilite
//
//  Created by Nesteforenko Andrey on 4/8/15.
//  Copyright (c) 2015 NIX. All rights reserved.
//

#import "MIUFileGenerator.h"
#import "MIUObjectsScanner.h"
#import "MIUClass.h"
#import "MIUMethod.h"
#import "MIUImplementation.h"
#import "MIUCopyWithZone.h"
#import "MIUEncodeWithCoder.h"
#import "MIUIsEqual.h"
#import "MIUInitWithCoder.h"
#import "MIUProtocolConfigurator.h"
#import "MIUDescription.h"
#import "MIUHash.h"

#import "MIUEnumsScanner.h"

#import "MIUClassStatistics.h"

// it is safety dictionary setter(check object to nil)
static NSString *MIUMacrosForPointerProperty = @"#define MIU_DICTIONARY_SET_POINTER_PROPERTY(dictionary, property)\\\n"
    @"    if ([self property] != nil)\\\n"
    @"    {\\\n"
    @"        [dictionary setObject:[self property] forKey:NSStringFromSelector(@selector(property))];\\\n"
    @"    }";

@interface MIUFileGenerator ()

@property(nonatomic, strong) NSString *resultFileContent;
@property(nonatomic, assign) BOOL isCurrentMethodIsAutoGenerated;
@property(nonatomic, assign) int lastOneMethodBracketIndex;
@property(nonatomic, assign) NSRange headerRangeOfCurrentMethod;

@end

@implementation MIUFileGenerator

- (NSArray<MIUClassStatistics *> *)generateFilesFromFilesAtPaths:(NSSet *)paths withRootProjectPath:(NSSet *)rootProjectPath
{
    MIUObjectsScanner *factory = [MIUObjectsScanner new];
    NSSet *classes = [factory classesFromPaths:paths withRootProjectPath:paths];
    NSMutableArray *classStatistics = [NSMutableArray new];
    NSSet *enums = [factory enumsFromPaths:rootProjectPath];

    for (MIUClass *class in classes)
    {
        if ([[class properties] count] != 0 || ![class isBase])
        {
            [self generateHeaderFromPath:[[class implementation] filePath] forInterfaceWithName:[class name]];
            NSString *contentOfFile = [NSString stringWithContentsOfFile:[[class implementation] filePath] encoding:NSUTF8StringEncoding error:nil];
            
            if (contentOfFile != nil)
            {
                NSArray *pathComponents = [[[class implementation] filePath] pathComponents];
                NSArray *lastTwoArray = [pathComponents subarrayWithRange:NSMakeRange(0, [pathComponents count] - 1)];
                
                if (![[NSFileManager defaultManager] fileExistsAtPath:[NSString stringWithFormat:@"%@/Generated/", [NSString pathWithComponents:lastTwoArray]]])
                {
                    [[NSFileManager defaultManager] createDirectoryAtPath:[NSString stringWithFormat:@"%@/Generated/", [NSString pathWithComponents:lastTwoArray]] withIntermediateDirectories:YES attributes:nil error:nil];
                }
                
                NSString *path = [[[class implementation] filePath] lastPathComponent];
                NSString *pathForGeneratedFile = [NSString stringWithFormat:@"%@/Generated/%@", [NSString pathWithComponents:lastTwoArray], path];
               
                MIUClassStatistics *statistics = [self editFile:contentOfFile withClass:class enums:enums];
                [classStatistics addObject:statistics];
                
                [[self progressDelegate] didFileGenerator:self allStatistics:classStatistics newOneItem:statistics];
                
                [[NSFileManager defaultManager] createFileAtPath:pathForGeneratedFile contents:nil attributes:nil];
                NSString *resultContent = [self insertImportMacrosesFileIntoString:_resultFileContent];
                [resultContent writeToFile:pathForGeneratedFile atomically:TRUE encoding:NSUTF8StringEncoding error:nil];
            }
        }
    }
    
    return classStatistics;
}

- (MIUClassStatistics *)editFile:(NSString *)file withClass:(MIUClass *)class enums:(NSSet *)enums
{
    NSMutableArray *methodStatistics = [NSMutableArray new];
    
    MIUClassStatistics *statistic = [MIUClassStatistics new];
    [statistic setGeneratingClass:class];
    
    MIUCopyWithZone *copyWithZoneMethod = [[MIUCopyWithZone alloc] initWithName:@"copyWithZone" returnType:@"id" isPointerReturnType:NO argName:@"theZone" argType:@"NSZone" isPointerArgType:YES];
    MIUMethodStatistics *copyWithZoneStatistics = [self fileChecker:file toExistedMethod:copyWithZoneMethod withClass:class];
    [copyWithZoneStatistics setProblematicProperties:[copyWithZoneMethod problematicProperties]];
    
    MIUEncodeWithCoder *encodeWithCoderMethod = [[MIUEncodeWithCoder alloc] initWithName:@"encodeWithCoder" returnType:@"void" isPointerReturnType:NO argName:@"theCoder" argType:@"NSCoder"isPointerArgType:YES];
    MIUMethodStatistics *encodeWithCoderStatistics = [self fileChecker:_resultFileContent toExistedMethod:encodeWithCoderMethod withClass:class];
    [encodeWithCoderStatistics setProblematicProperties:[encodeWithCoderMethod problematicProperties]];
    
    MIUInitWithCoder *initWithCoder = [[MIUInitWithCoder alloc] initWithName:@"initWithCoder" returnType:@"id" isPointerReturnType:NO argName:@"theDecoder" argType:@"NSCoder" isPointerArgType:YES];
    MIUMethodStatistics *initWithCoderStatistics = [self fileChecker:_resultFileContent toExistedMethod:initWithCoder withClass:class];
    [initWithCoderStatistics setProblematicProperties:[initWithCoder problematicProperties]];

    MIUIsEqual *isEqualMethod = [[MIUIsEqual alloc] initWithName:@"isEqual" returnType:@"BOOL" isPointerReturnType:NO argName:@"theObject" argType:[NSString stringWithFormat:@"%@", [class name]] isPointerArgType:YES];
    [isEqualMethod setEnums:enums];
    MIUMethodStatistics *isEqualStatistics = [self fileChecker:_resultFileContent toExistedMethod:isEqualMethod withClass:class];
    [isEqualStatistics setProblematicProperties:[isEqualMethod problematicProperties]];
    
    MIUDescription *decriptionMethod = [[MIUDescription alloc] initWithName:@"description" returnType:@"NSString" isPointerReturnType:YES argName:nil argType:nil isPointerArgType:NO];
    [decriptionMethod setEnums:enums];
    MIUMethodStatistics *decriptionStatistics = [self fileChecker:_resultFileContent toExistedMethod:decriptionMethod withClass:class];
    [decriptionStatistics setProblematicProperties:[decriptionMethod problematicProperties]];
    
    MIUHash *hashMethod = [[MIUHash alloc] initWithName:@"hash" returnType:@"NSUInteger" isPointerReturnType:NO argName:nil argType:nil isPointerArgType:NO];
    [hashMethod setEnums:enums];
    MIUMethodStatistics *hashStatistics = [self fileChecker:_resultFileContent toExistedMethod:hashMethod withClass:class];
    [hashStatistics setProblematicProperties:[hashMethod problematicProperties]];
    
    [methodStatistics addObjectsFromArray:@[copyWithZoneStatistics, encodeWithCoderStatistics, initWithCoderStatistics, isEqualStatistics, decriptionStatistics, hashStatistics]];
    [statistic setMethodsStatistic:methodStatistics];
    
    return statistic;
}

- (MIUMethodStatistics *)fileChecker:(NSString *)file toExistedMethod:(MIUMethod *)method withClass:(MIUClass *)class
{
    MIUMethodStatistics *methodStatistics = [MIUMethodStatistics new];
    MIUMethodState state;
    
    _isCurrentMethodIsAutoGenerated = NO;
    _resultFileContent = [file copy];
    
    NSString *newMethodBody = [NSString stringWithFormat:@"%@\n%@", [method headerOfMethod], [method methodBodyForClass:class]];
    
    if ([self checkExistingMethodWithSignature:method inString:file])
    {
        state = MIUMethodStateSupportedByUser;
        
        if ([self isCurrentMethodIsAutoGenerated] == YES)
        {
            state = MIUMethodStateTheSame;
            [self indexesDataForCurrentMethodInFile:_resultFileContent];
            
            NSString *existingMethodBody = [_resultFileContent substringWithRange:NSMakeRange((int)(_headerRangeOfCurrentMethod.location + _headerRangeOfCurrentMethod.length), _lastOneMethodBracketIndex)];
            
            if (![self isExistingMethodBody:existingMethodBody asExpectedMethodBody:[method methodBodyForClass:class]])
            {
                state = MIUMethodStateRegenerated;
                _resultFileContent = [self replaceMethod:method inString:file withString:newMethodBody];
            }
        }
    }
    else
    {
        state = MIUMethodStateGenerated;
        _resultFileContent = [self insertMethod:newMethodBody intoFile:_resultFileContent inImplementationWithName:[[class implementation] name]];
    }
    
    [methodStatistics setState:state];
    [methodStatistics setMethod:method];
    
    return methodStatistics;
}

- (NSString *)replaceMethod:(MIUMethod *)method inString:(NSString *)fileContent withString:(NSString *)newMethodBody
{
    NSString *pattern;
    
    if ([method isKindOfClass:[MIUIsEqual class]] ||
        [method isKindOfClass:[MIUHash class]] ||
        [method isKindOfClass:[MIUDescription class]])
    {
        // pattern to check existence already generated method IsEqual, hash, description
        pattern = [NSString stringWithFormat:@"(\\/\\/\\s*\\bgenerated\\b\\s*){0,1}\\-\\s*\\(\\s*%@\\s*%@\\)\\s*%@\\s*((\\:\\s*\\(\\s*%@\\s*%@\\)\\s*\\w*)){0,1}(.|\\s)*"
                   , [NSString stringWithFormat:@"(?:\\b%@\\b|\\bid\\b)", [method returnType]], [method isPointerReturnType] ? @"\\*\\s*" : @"", [method name], [NSString stringWithFormat:@"(?:%@|id)", [method argumentType]], [method isPointerArgumentType] ? @"\\*\\s*" : @""];
    }
    else
    {
        // pattern to check existence already generated method initWithCoder, encodeWithCoder
        pattern = [NSString stringWithFormat:@"(\\/\\/\\s*\\bgenerated\\b\\s*){0,1}\\-\\s*\\((\\s*%@\\s*%@\\s*\\)\\s*%@\\s*\\:\\s*\\(\\s*%@\\s*%@\\s*\\)\\s*\\w*)(.|\\s)*", [method returnType], [method isPointerReturnType] ? @"\\*" : @"", [method name], [method argumentType], [method isPointerArgumentType] ? @"\\*" : @""];
    }
    
    NSRegularExpression *regex = [NSRegularExpression regularExpressionWithPattern:pattern options:0 error:NULL];
    NSTextCheckingResult *match = [regex firstMatchInString:fileContent options:0 range:NSMakeRange(0, [fileContent length])];
    
    if (match != nil)
    {
        int indexOfMethodStart = (int)match.range.location;
        int methodLenInByte = 0;
        
        NSString *str = [fileContent substringWithRange:[match rangeAtIndex:0]];
        int openBracketCount = 0, closeBraceketCount = 0;
        unsigned int len = (unsigned int)[str length];
        char buffer[len];
        strncpy(buffer, [str UTF8String], len);
        
        for (int i = 0; i < len; ++i)
        {
            char current = buffer[i];
            
            if (current == '{')
            {
                ++openBracketCount;
            }
            else if (current == '}')
            {
                ++closeBraceketCount;
            }
            
            if (openBracketCount == closeBraceketCount && openBracketCount != 0)
            {
                methodLenInByte = i + 1;
                
                break;
            }
        }
        
        return [fileContent stringByReplacingCharactersInRange:NSMakeRange(indexOfMethodStart, methodLenInByte) withString:newMethodBody];
    }
    
    return nil;
}

- (NSString *)insertMethod:(NSString *)method intoFile:(NSString *)fileContent inImplementationWithName:(NSString *)implementationName
{
    // pattern to get NSRange of implementation section from fileContent
    NSString *pattern = [NSString stringWithFormat:@"\\@implementation\\s*%@\\s*(\\s|.)*()\\@end", implementationName];
    NSRegularExpression *regex = [NSRegularExpression regularExpressionWithPattern:pattern options:0 error:NULL];
    NSTextCheckingResult *match = [regex firstMatchInString:fileContent options:0 range:NSMakeRange(0, [fileContent length])];
    
    if (match != nil)
    {
        return [fileContent stringByReplacingCharactersInRange:[match rangeAtIndex:2] withString:[NSString stringWithFormat:@"%@\n\n", method]];
    }
    
    return nil;
}

- (BOOL)isExistingMethodBody:(NSString *)existingMethodBody asExpectedMethodBody:(NSString *)expectedMethodBody
{
    if ([existingMethodBody isEqualToString:expectedMethodBody])
    {
        return YES;
    }
    
    return NO;
}

- (void)indexesDataForCurrentMethodInFile:(NSString *)fileContent
{
    int methodLenInByte = 0;
    
    int indexOfMethodBodyStart = (int)(_headerRangeOfCurrentMethod.location + _headerRangeOfCurrentMethod.length);
    
    NSString *methodBody = [fileContent substringWithRange:NSMakeRange(indexOfMethodBodyStart, [fileContent length] - indexOfMethodBodyStart)];
    int openBracketCount = 0, closeBraceketCount = 0;
    unsigned int len = (unsigned int)[methodBody length];
    char buffer[len];
    strncpy(buffer, [methodBody UTF8String], len);
    
    for (int i = 0; i < len; ++i)
    {
        char current = buffer[i];
        
        if (current == '{')
        {
            ++openBracketCount;
        }
        else if (current == '}')
        {
            ++closeBraceketCount;
        }
        
        if (openBracketCount == closeBraceketCount && openBracketCount != 0)
        {
            methodLenInByte = i + 1;
            
            break;
        }
    }
    
    _lastOneMethodBracketIndex = methodLenInByte;
}

- (BOOL)checkExistingMethodWithSignature:(MIUMethod *)method inString:(NSString *)fileContent
{
    NSString *pattern;
    
    if ([method isKindOfClass:[MIUIsEqual class]] ||
        [method isKindOfClass:[MIUHash class]] ||
        [method isKindOfClass:[MIUDescription class]])
    {
        // pattern to check existence already generated method IsEqual, hash, description
        pattern = [NSString stringWithFormat:@"(\\s*\\/\\/ \\bgenerated\\b\\s*){0,1}\\-\\s*\\(\\s*%@\\s*%@\\)\\s*%@\\s*((\\:\\s*\\(\\s*%@\\s*%@\\)\\s*\\w*)){0,1}\\s*"
                   , [NSString stringWithFormat:@"(?:\\b%@\\b|\\bid\\b)", [method returnType]], [method isPointerReturnType] ? @"\\*\\s*" : @"", [method name], [NSString stringWithFormat:@"(?:%@|id)", [method argumentType]], [method isPointerArgumentType] ? @"\\*\\s*" : @""];
    }
    else
    {
        // pattern to check existence already generated method initWithCoder, encodeWithCoder
        pattern = [NSString stringWithFormat:@"(\\s*\\/\\/ \\bgenerated\\b\\s*){0,1}\\-\\s*\\((\\s*%@\\s*%@\\s*\\)\\s*%@\\s*\\:\\s*\\(\\s*%@\\s*%@\\s*\\)\\s*\\w*)\\s*", [method returnType], [method isPointerReturnType] ? @"\\*" : @"", [method name], [method argumentType], [method isPointerArgumentType] ? @"\\*" : @""];
    }
   
    NSRegularExpression *regex = [NSRegularExpression regularExpressionWithPattern:pattern options:0 error:NULL];
    
    NSTextCheckingResult *match = [regex firstMatchInString:fileContent options:0 range:NSMakeRange(0, [fileContent length])];
    
    if (match != nil)
    {
        _headerRangeOfCurrentMethod = [match rangeAtIndex:0];
        
        if ([match rangeAtIndex:1].length != 0)
        {
            _isCurrentMethodIsAutoGenerated = YES;
        }
        
        return YES;
    }
    
    return NO;
}

- (void)generateHeaderFromPath:(NSString *)path forInterfaceWithName:(NSString *)interfaceName
{
    MIUProtocolConfigurator *protocolConfigurator = [MIUProtocolConfigurator new];
    NSArray *pathComponents = [path pathComponents];
    
    if (pathComponents != nil)
    {
        NSString *headerName = [[pathComponents lastObject] stringByReplacingOccurrencesOfString:@".m" withString:@".h"];
        
        NSString *pathForHeader = [NSString stringWithFormat:@"%@/%@", [NSString pathWithComponents:[pathComponents subarrayWithRange:NSMakeRange(0, [pathComponents count] - 1)]], headerName];
        NSString *contentOfFile = [NSString stringWithContentsOfFile:pathForHeader encoding:NSUTF8StringEncoding error:nil];
        
        if (contentOfFile != nil)
        {
            NSString *headerConformedToProtocols = [protocolConfigurator configureProtocolListInString:contentOfFile forInterfaceWithName:interfaceName];
            [[NSFileManager defaultManager] createDirectoryAtPath:[NSString stringWithFormat:@"%@/Generated/", [NSString pathWithComponents:[pathComponents subarrayWithRange:NSMakeRange(0, [pathComponents count] - 1)]]] withIntermediateDirectories:YES attributes:nil error:nil];
            NSString *pathForGeneratedHeader = [NSString stringWithFormat:@"%@/Generated/%@", [NSString pathWithComponents:[pathComponents subarrayWithRange:NSMakeRange(0, [pathComponents count] - 1)]], headerName];
            [[NSFileManager defaultManager] createFileAtPath:pathForGeneratedHeader contents:nil attributes:nil];
            [headerConformedToProtocols writeToFile:pathForGeneratedHeader atomically:YES encoding:NSUTF8StringEncoding error:nil];
        }
    }
}

- (NSString *)insertImportMacrosesFileIntoString:(NSString *)stringWithInterface
{
    // pattern to get file location after #import statements to insert macros for safety inserting in dictionary
    NSString *pattern = @"\\#import\\s*[\"<].*[\">]()";
    NSRegularExpression *regex = [NSRegularExpression regularExpressionWithPattern:pattern options:0 error:NULL];
    NSArray *matches = [regex matchesInString:stringWithInterface options:0 range:NSMakeRange(0, [stringWithInterface length])];
    if ([self checkIsMacrosAlreadyAddedInString:stringWithInterface] == NO)
    {
        if (matches != nil)
        {
            NSTextCheckingResult *lastOneMatch = [matches lastObject];
            int indexToInsertImport = (int)([lastOneMatch rangeAtIndex:1].location + [lastOneMatch rangeAtIndex:1].length);
            NSMutableString *mutableStringWithIterface = [stringWithInterface mutableCopy];
            [mutableStringWithIterface insertString:[NSString stringWithFormat:@"\n\n%@", MIUMacrosForPointerProperty] atIndex:indexToInsertImport];
            
            return mutableStringWithIterface;
        }
    }
    
    return stringWithInterface;
}

- (BOOL)checkIsMacrosAlreadyAddedInString:(NSString *)string
{
    // pattern to check existance of "Safe dictionary setter" macros
    NSString *pattern = @"\\#define MIU_DICTIONARY_SET_POINTER_PROPERTY";
    NSRegularExpression *regex = [NSRegularExpression regularExpressionWithPattern:pattern options:0 error:NULL];
    NSTextCheckingResult *match = [regex firstMatchInString:string options:0 range:NSMakeRange(0, [string length])];
    
    if (match != nil)
    {
        return YES;
    }
    
    return NO;
}

- (NSMutableArray *)createStatisticsObjectsFromClasses:(NSArray *)classes
{
    NSMutableArray *newArr = [NSMutableArray new];
    
    for (MIUClass *class in classes)
    {
        MIUClassStatistics *statistics = [MIUClassStatistics new];
        [statistics setGeneratingClass:class];
    }
    
    return newArr;
}

@end
